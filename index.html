<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>360° Audio‑Driven XR Player</title>
<!-- Preload critical assets -->
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js" as="script">
<script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,sans-serif;color:#fff}

/* Container styles */
#xrContainer{position:absolute;inset:0}
#landingOverlay{position:fixed;inset:0;z-index:700;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:40px;text-align:center;gap:20px}
#audioOnly{position:absolute;top:0;left:0;right:0;display:none;flex-direction:column;align-items:center;padding-top:20px;gap:20px}

/* Artwork styles */
.artwork-wrapper{position:relative;width:calc(100% - 40px);max-width:400px}
.artwork{width:100%;aspect-ratio:1/1;border-radius:16px;object-fit:cover;box-shadow:0 4px 12px rgba(0,0,0,.4)}

/* Standard button styles */
.btn {
  border: none;
  border-radius: 8px;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #fff;
  background: rgba(60, 60, 60, 0.8);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.btn:hover {
  background: rgba(80, 80, 80, 0.9);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Button variants */
.btn-primary {
  background: rgba(78, 130, 230, 0.9);
}

.btn-primary:hover {
  background: rgba(100, 150, 255, 0.95);
}

.btn-accent {
  background: rgba(235, 87, 87, 0.9);
}

.btn-accent:hover {
  background: rgba(255, 100, 100, 0.95);
}

/* Touch device adaptations */
@media (hover: none) {
  .btn:hover {
    background: rgba(60, 60, 60, 0.8);
    transform: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }
  
  .btn-primary:hover {
    background: rgba(78, 130, 230, 0.9);
  }
  
  .btn-accent:hover {
    background: rgba(235, 87, 87, 0.9);
  }
  
  .btn:active {
    opacity: 0.7;
  }
}

/* Specific button styles */
#beginBtn{
  background: rgba(78, 130, 230, 0.9);
  border-radius: 30px;
  padding: 18px 36px;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  width: calc(100% - 40px);
  max-width: 320px;
  color: white;
}

#beginBtn:hover {
  background: rgba(100, 150, 255, 0.95);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#toggleModeButton{
  position: absolute;
  bottom: 10px;
  right: 10px;
  border-radius: 20px;
  padding: 8px 14px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

#toggleModeButton.disabled{
  pointer-events: none;
  opacity: .5;
}

/* Status indicator */
.status-dot{
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: orange;
  display: inline-block;
}

/* Track info display */
#trackInfo{
  position: fixed;
  bottom: 140px;
  left: 50%;
  transform: translateX(-50%);
  max-width: calc(100% - 40px);
  text-align: center;
  font-size: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  z-index: 180;
}

/* Audio player */
#audioPlayer{
  position: fixed;
  bottom: 80px;
  left: 0;
  right: 0;
  margin: 0 auto;
  width: calc(100% - 20px);
  max-width: 600px;
  z-index: 200;
  background: #111;
  border-radius: 6px;
  padding: 2px 0;
}

/* Chapter navigation */
.chapter-nav{
  position: fixed;
  bottom: 10px;
  left: 0;
  right: 0;
  margin: 0 auto;
  width: calc(100% - 20px);
  max-width: 600px;
  display: flex;
  gap: 10px;
  z-index: 190;
}

.nav-btn{
  flex: 1;
  background: rgba(40, 40, 40, 0.7);
  border: none;
  border-radius: 8px;
  padding: 12px 0;
  font-size: 20px;
  color: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background: rgba(60, 60, 60, 0.9);
}

/* Top bar controls */
.top-bar{
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 150;
}

.ui-btn{
  background: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.ui-btn:hover {
  background: rgba(30, 30, 30, 0.8);
}

/* CTA overlay */
#ctaOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 500;
  cursor: pointer;
}

.cta-box{
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  transition: transform 0.2s ease;
}

.cta-box:hover {
  transform: scale(1.02);
}

.cta-logo{
  width: 120px;
  height: 120px;
  background: #fff;
  border-radius: 50%;
}

/* Loading spinner */
#loadingSpinner{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 450;
  pointer-events: none;
}

.spinner{
  width: 60px;
  height: 60px;
  border: 6px solid #fff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin{
  to{
    transform: rotate(360deg);
  }
}
</style>
</head>
<body>
<div id="landingOverlay"><h1>Welcome to the Chinatown Audio Tour</h1><p>Immerse yourself in history as you explore.</p><button id="beginBtn" class="btn">Begin Tour</button></div>
<div id="xrContainer">
  <a-scene embedded 
    vr-mode-ui="enabled:false" 
    device-orientation-permission-ui="enabled:false" 
    loading-screen="enabled:false"
    renderer="antialias: true; alpha: true; precision: medium"
    onload="this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));">
    <a-assets>
      <video id="video360" crossorigin="anonymous" playsinline webkit-playsinline muted preload="auto">
        <source id="videoSource" type="video/mp4">
      </video>
    </a-assets>
    <a-videosphere id="videosphere" src="#video360" rotation="0 -90 0" visible="true"></a-videosphere>
    <a-entity id="cameraEntity" camera look-controls="reverseMouseDrag:true;touchEnabled:true" position="0 1.6 0"></a-entity>
  </a-scene>
</div>
<div id="audioOnly"><div class="artwork-wrapper"><img id="artworkImg" class="artwork" alt=""><button id="toggleModeButton" class="btn disabled"><span class="status-dot"></span><span>XR Mode</span></button></div></div>
<div id="trackInfo"></div>
<div class="top-bar">
  <button id="recenterButton" class="ui-btn btn">Recenter</button>
  <button id="devToggleButton" class="ui-btn btn">Toggle Teaser</button>
  <button id="xrToggleModeButton" class="ui-btn btn">Audio Only</button>
</div>
<div id="loadingSpinner"><div class="spinner"></div></div>
<audio id="audioPlayer" controls crossorigin="anonymous"></audio>
<div class="chapter-nav" id="chapterNav">
  <button id="prevChapter" class="nav-btn">&laquo;</button>
  <button id="nextChapter" class="nav-btn">&raquo;</button>
</div>
<div id="ctaOverlay"><div class="cta-box" id="ctaBox"><div class="cta-logo"></div><div class="cta-text">Take the full tour here</div></div></div>
<script>
const XR_src="https://cmm-cloud-2.s3.us-west-1.amazonaws.com/WALKING+TOURS/2025-04-10-JAPANTOWN-XR/2025-04-21-CHINATOWN-XR-UPDATE/2025-04-21-CHINATOWN-XR-2b-low.mp4";
const audio_src="https://cmm-cloud-2.s3.us-west-1.amazonaws.com/WALKING+TOURS/2025-03-15-CHINATOWN/2025-03-15-CHINATOWN-MP3S/2025-04-21-SHORTER-MP3-CHAPTERS/2025-04-21-Chapter+2+Look+Tin+Eli.mp3";
const thumbnail_src="https://placehold.co/1024x1024/1E1E1E/FFFFFF?text=Album+Art";
const chapterName="Look Tin Eli",chapterOrder=2,tourName="Chinatown Tour";
const isXR=true,isTeaser=false,outroCTA_time=20,outroCTA_backlink="https://example.com/full-tour";
const devToggleAllowed=true,isMobile=matchMedia('(pointer:coarse)').matches;

// Performance optimization settings
const PERFORMANCE = {
  // Lower is better for performance, higher for quality
  textureQuality: isMobile ? 0.5 : 1.0,
  useProgressiveLoading: true,
  // Controls how aggressively we downscale video
  videoScale: isMobile ? 0.6 : 1.0,
  // How much to reduce pixel ratio on mobile
  pixelRatioScale: isMobile ? 0.7 : 1.0,
  // Buffer size for mobile (in seconds)
  mobileBufferSize: 30
};

// Configure video quality for mobile devices
const configureVideoForDevice = () => {
  if (isMobile) {
    // Reduce video element size for mobile to improve performance
    const video = document.getElementById('video360');
    if (video) {
      // Set maximum dimensions for mobile to help with performance
      video.style.maxWidth = `${Math.round(1280 * PERFORMANCE.videoScale)}px`;
      video.style.maxHeight = `${Math.round(720 * PERFORMANCE.videoScale)}px`;
      
      // For mobile, we can also set lower resolution on the video element directly
      // This forces a lower internal resolution in memory
      video.width = Math.round(1280 * PERFORMANCE.videoScale);
      video.height = Math.round(720 * PERFORMANCE.videoScale);
      
      // Adjust buffering strategy - this is key for mobile performance
      // Tell the browser how much to buffer (default is often too much for mobile memory)
      try {
        // Most browsers support this, but wrap in try/catch for safety
        video.preload = "auto"; // Ensure preloading is enabled
        
        // Specify buffer size (not all browsers support this)
        if ('buffered' in video) {
          // Try to set a smaller buffer size to prevent memory issues
          // This is a custom attribute that may not be respected by all browsers
          video.bufferSize = PERFORMANCE.mobileBufferSize;
        }
      } catch (e) {
        console.log("Could not set buffer parameters:", e);
      }
      
      // Disable hardware acceleration if it's causing problems
      // This can sometimes resolve texture loading issues on certain devices
      // Uncomment if needed:
      // video.style.webkitTransform = 'translateZ(0)';
      // video.style.transform = 'translateZ(0)';
    }
    
    // Apply texture quality settings (reduces GPU memory usage and improves performance)
    if (window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
      const renderer = AFRAME.scenes[0].renderer;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * PERFORMANCE.pixelRatioScale, 1.5));
    }
  }
};

window.addEventListener('DOMContentLoaded',()=>{
 const $=id=>document.getElementById(id);
 const audio=$('audioPlayer'),video=$('video360'),vs=$('videoSource');
 const art=$('artworkImg'),track=$('trackInfo'),camera=$('cameraEntity');
 const recBtn=$('recenterButton'),modeBtn=$('toggleModeButton'),devBtn=$('devToggleButton');
 const xrModeBtn=$('xrToggleModeButton');
 const xrWrap=$('xrContainer'),audioOnly=$('audioOnly');
 const landing=$('landingOverlay'),begin=$('beginBtn');
 const spinner=$('loadingSpinner'),overlay=$('ctaOverlay'),ctaBox=$('ctaBox');
 const chapterNav=$('chapterNav');
 const videosphere=$('videosphere');
 
 // Spinner control variables
 let spinnerTimeout = null;
 let spinnerActive = false;
 
 // Control spinner with debounce
 const showSpinner = () => {
   if (spinnerTimeout) {
     clearTimeout(spinnerTimeout);
   }
   if (!spinnerActive) {
     spinner.style.display = 'flex';
     spinnerActive = true;
   }
 };
 
 const hideSpinner = () => {
   if (spinnerTimeout) {
     clearTimeout(spinnerTimeout);
   }
   // Add delay before hiding to prevent flashes
   spinnerTimeout = setTimeout(() => {
     spinner.style.display = 'none';
     spinnerActive = false;
   }, 300);
 };
 
 // Set video source
 vs.src=XR_src;
 video.load();
 
 // Always ensure video is muted regardless of other settings
 video.muted = true;
 
 // Ensure videosphere is visible
 videosphere.setAttribute('visible', 'true');
 
 // Add error logging for debugging
 video.addEventListener('error', (e) => {
   console.error('Video error:', video.error, e);
   alert('Video error: ' + (video.error ? video.error.message : 'unknown'));
 });
 
 audio.innerHTML=`<source src="${audio_src}" type="audio/mpeg">`;
 // Apply custom controls to audio element
 audio.controlsList = "nodownload nofullscreen noremoteplayback";
 // Disable playback rate controls via CSS
 const styleEl = document.createElement('style');
 styleEl.textContent = `
   #audioPlayer::-webkit-media-controls-timeline-container { display: flex !important; }
   #audioPlayer::-webkit-media-controls-play-button { display: flex !important; }
   #audioPlayer::-webkit-media-controls-current-time-display { display: flex !important; }
   #audioPlayer::-webkit-media-controls-time-remaining-display { display: flex !important; }
   #audioPlayer::-webkit-media-controls-mute-button { display: flex !important; }
   #audioPlayer::-webkit-media-controls-volume-slider { display: flex !important; }
   #audioPlayer::-webkit-media-controls-toggle-closed-captions-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-fullscreen-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-download-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-overflow-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-playback-rate-button { display: none !important; }
 `;
 document.head.appendChild(styleEl);
 art.src=thumbnail_src;
 track.textContent=`Chapter ${chapterOrder} – ${chapterName} | ${tourName}`;
 let teaser=isTeaser,xrAllowed=isXR||teaser,xrMode=false;
 let videoReady=false,audioReady=false,overlayShown=false;
 const dot=modeBtn.querySelector('.status-dot');
 
 const updateXrButton=()=>{
   const ready=videoReady&&audioReady;
   modeBtn.classList.toggle('disabled',!ready);
   modeBtn.disabled=!ready;
   dot.style.background=ready?'limegreen':'orange';
 };
 
 const layout=()=>{
   modeBtn.style.display=xrAllowed&&!teaser?'inline-flex':'none';
   recBtn.style.display=xrMode?'inline-block':'none';
   xrModeBtn.style.display=(xrMode&&xrAllowed&&!teaser)?'inline-block':'none';
   chapterNav.style.display=teaser?'none':'flex';
   xrWrap.style.display=(xrMode&&xrAllowed)?'block':'none';
   audioOnly.style.display=(!xrMode||!xrAllowed)?'flex':'none';
   modeBtn.lastChild.textContent=xrMode?' Audio Only':' XR Mode';
   
   // Ensure A-Frame scene refreshes when made visible
   if(xrMode && xrAllowed) {
     forceAFrameRender();
     
     // For mobile, try to play video even if muted
     if(isMobile && videoReady && !video.playing) {
       video.play().catch(e => console.log("Initial mobile play attempt:", e));
     }
   }
 };
 
 // Modify force render function to manage spinner state 
 const forceAFrameRender = () => {
   // Show spinner at the beginning of render attempts
   showSpinner();
   
   if(window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
     console.log("Forcing A-Frame render");
     
     // Apply performance settings
     const renderer = AFRAME.scenes[0].renderer;
     
     // Apply texture quality settings
     if (isMobile) {
       // Lower texture maximum size for mobile (reduces VRAM usage)
       renderer.capabilities.maxTextureSize = 2048;
       
       // On mobile, force power preference to high-performance
       // But make it optional to avoid crashes on unsupported devices
       if (renderer.getContext().canvas.getContext) {
         try {
           renderer.getContext().canvas.getContext('webgl2', { powerPreference: 'high-performance' });
         } catch (e) {
           console.log("Power preference setting not supported");
         }
       }
       
       // Tell the renderer to prioritize performance over quality
       if (renderer.debug) {
         renderer.debug.checkShaderErrors = false;
       }
     }
     
     // Force composite
     renderer.autoClear = true;
     
     AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
     window.dispatchEvent(new Event('resize'));
     
     // Explicitly check videosphere visibility
     if(videosphere) {
       videosphere.setAttribute('visible', 'true');
       console.log("Ensuring videosphere visibility");
     }
     
     // Schedule multiple renders with increasing delays - use fewer renders on mobile
     const renderDelays = isMobile ? [100, 800] : [100, 400, 800, 1500]; 
     let lastDelay = Math.max(...renderDelays);
     
     renderDelays.forEach(delay => {
       setTimeout(() => {
         if(AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
           console.log(`Scheduled render at ${delay}ms`);
           AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
           
           // Check videosphere visibility again during each render
           if(videosphere) {
             videosphere.setAttribute('visible', 'true');
           }
           
           // Only hide spinner after the last render attempt or after 3 seconds have passed
           // This helps prevent the spinner from being stuck on mobile
           if (delay === lastDelay) {
             // Force hide spinner after a reasonable time
             if (isMobile) {
               // For mobile, we'll add additional forced spinner removal
               setTimeout(() => {
                 if (spinnerActive) {
                   console.log("Force hiding spinner after timeout");
                   spinner.style.display = 'none';
                   spinnerActive = false;
                 }
               }, 5000);
             }
             hideSpinner();
           }
         }
       }, delay);
     });
   } else {
     // If A-Frame isn't ready, hide spinner after timeout
     setTimeout(hideSpinner, 800);
   }
 };
 
 // Setup observer to detect when container becomes visible
 const containerObserver = new MutationObserver((mutations) => {
   mutations.forEach((mutation) => {
     if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
       const target = mutation.target;
       if (target.style.display === 'block' && target.id === 'xrContainer') {
         console.log("XR container now visible - forcing render");
         forceAFrameRender();
       }
     }
   });
 });
 
 // Start observing the container for visibility changes
 containerObserver.observe(xrWrap, { attributes: true });
 
 if(teaser)xrMode=true;
 layout();
 updateXrButton();
 
 // Video loading events
 video.addEventListener('loadedmetadata', () => {
   console.log("Video metadata loaded");
   
   // For mobile, apply some optimizations immediately after metadata loads
   if (isMobile) {
     // Lower video quality via video element properties
     video.width = Math.round(1280 * PERFORMANCE.videoScale);
     video.height = Math.round(720 * PERFORMANCE.videoScale);
   }
 });
 
 video.addEventListener('loadeddata',()=>{
   console.log("Video data loaded");
   videoReady=true;
   updateXrButton();
   
   // Force renderer update
   if(window.AFRAME && AFRAME.scenes[0]) {
     AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
     
     // Ensure videosphere is visible after video loads
     if(videosphere) {
       videosphere.setAttribute('visible', 'true');
       
       // For mobile, optimize the videosphere material immediately
       if (isMobile) {
         try {
           // Get the videosphere mesh
           const material = videosphere.getObject3D('mesh')?.material;
           if (material && material.map) {
             // Apply optimizations to the video texture
             material.map.minFilter = THREE.LinearFilter;
             material.map.generateMipmaps = false;
             material.needsUpdate = true;
             console.log("Applied early texture optimizations to videosphere");
           }
         } catch (e) {
           console.log("Could not apply early texture optimizations:", e);
         }
       }
     }
   }
   
   hideSpinner();
   
   // For mobile, try to play muted video once it's loaded
   if(isMobile && xrMode) {
     video.muted = true;
     video.play().catch(e => console.log("Auto-play attempt after load:", e));
   }
 });
 
 // Set up buffer monitoring and recovery for mobile
 let lastBufferCheck = 0;
 let bufferWarnings = 0;
 const MAX_BUFFER_WARNINGS = 3;
 let isRecoveringBuffer = false;
 
 // Monitor buffer status and attempt recovery if needed
 const monitorVideoBuffer = () => {
   if (!isMobile || !videoReady || !xrMode) return;
   
   const now = Date.now();
   if (now - lastBufferCheck < 5000) return; // Check every 5 seconds
   lastBufferCheck = now;
   
   if (video.paused) return; // Don't check if paused
   
   try {
     // Get current buffer state
     const buffered = video.buffered;
     let isBufferHealthy = false;
     
     if (buffered.length > 0) {
       // Check if we have enough buffer ahead
       const currentTime = video.currentTime;
       const bufferedEnd = buffered.end(buffered.length - 1);
       const bufferedAhead = bufferedEnd - currentTime;
       
       console.log(`Buffer status: ${bufferedAhead.toFixed(2)}s ahead of current playback`);
       
       // Consider buffer healthy if we have at least 10 seconds ahead
       isBufferHealthy = bufferedAhead >= 10;
     }
     
     if (!isBufferHealthy && !isRecoveringBuffer) {
       bufferWarnings++;
       console.log(`Buffer warning ${bufferWarnings}/${MAX_BUFFER_WARNINGS}`);
       
       if (bufferWarnings >= MAX_BUFFER_WARNINGS) {
         console.log("Buffer critically low, attempting recovery");
         attemptBufferRecovery();
       }
     } else if (isBufferHealthy) {
       // Reset warning count if buffer is healthy
       bufferWarnings = 0;
     }
   } catch (e) {
     console.log("Error checking buffer:", e);
   }
 };
 
 // Attempt to recover from buffer issues
 const attemptBufferRecovery = () => {
   if (isRecoveringBuffer) return;
   isRecoveringBuffer = true;
   
   // Show spinner during recovery
   showSpinner();
   
   console.log("Starting buffer recovery process");
   
   // Store current time and play state
   const currentTime = video.currentTime;
   const wasPlaying = !video.paused;
   
   // Pause video to allow buffer to fill
   if (!video.paused) {
     video.pause();
   }
   
   // For more serious recovery, reload the video source
   setTimeout(() => {
     // Load without autoplay
     video.load();
     
     // Watch for data loading
     const checkLoaded = () => {
       // Check if enough data is loaded (at least to current position plus 5s)
       try {
         if (video.readyState >= 3) { // HAVE_FUTURE_DATA
           const buffered = video.buffered;
           let hasEnoughBuffer = false;
           
           for (let i = 0; i < buffered.length; i++) {
             if (buffered.start(i) <= currentTime && buffered.end(i) >= currentTime + 5) {
               hasEnoughBuffer = true;
               break;
             }
           }
           
           if (hasEnoughBuffer) {
             finishRecovery();
             return;
           }
         }
         
         // Check again in 1 second if not ready
         setTimeout(checkLoaded, 1000);
       } catch (e) {
         console.log("Error in buffer check:", e);
         finishRecovery(); // Proceed anyway after error
       }
     };
     
     // Start checking loading progress
     checkLoaded();
     
     // Force recovery to complete after maximum wait time
     setTimeout(() => {
       if (isRecoveringBuffer) {
         console.log("Forcing recovery completion after timeout");
         finishRecovery();
       }
     }, 10000);
   }, 500);
   
   // Final step of recovery
   const finishRecovery = () => {
     if (!isRecoveringBuffer) return;
     
     console.log("Finishing buffer recovery");
     
     // Seek to the stored position
     try {
       video.currentTime = currentTime;
     } catch (e) {
       console.log("Seek error in recovery:", e);
     }
     
     // Apply texture optimizations again
     if (videosphere) {
       try {
         const material = videosphere.getObject3D('mesh')?.material;
         if (material && material.map) {
           material.map.minFilter = THREE.LinearFilter;
           material.map.magFilter = THREE.LinearFilter;
           material.map.generateMipmaps = false;
           material.needsUpdate = true;
         }
       } catch (e) {
         console.log("Error reapplying texture optimizations:", e);
       }
     }
     
     // Resume if it was playing
     if (wasPlaying) {
       video.play().catch(e => console.log("Play error in recovery:", e));
     }
     
     // Hide spinner and reset state
     hideSpinner();
     isRecoveringBuffer = false;
     bufferWarnings = 0;
   };
 };
 
 // Set up regular buffer monitoring
 const bufferMonitorInterval = setInterval(monitorVideoBuffer, 5000);
 
 // Cleanup interval on page unload
 window.addEventListener('beforeunload', () => {
   clearInterval(bufferMonitorInterval);
 });

 // Add a stalled/error event handler to recover from video loading issues
 video.addEventListener('stalled', () => {
   console.log("Video stalled - attempting recovery");
   if (videoReady && xrMode) {
     // Try to recover by reloading video source
     setTimeout(() => {
       // On mobile, increment our buffer warning count
       if (isMobile) {
         bufferWarnings++;
         if (bufferWarnings >= MAX_BUFFER_WARNINGS) {
           attemptBufferRecovery();
         }
       } else {
         // On desktop just reload
         video.load();
         video.play().catch(e => console.log("Stalled recovery attempt:", e));
       }
     }, 1000);
   }
 });

 // Add specific handling for cases where video decoding is interrupted
 video.addEventListener('waiting', () => {
   console.log("Video waiting for data");
   showSpinner();
   
   // On mobile, this could indicate buffer or memory issues
   if (isMobile) {
     bufferWarnings++;
     
     // If we've hit waiting state multiple times, try recovery
     if (bufferWarnings >= MAX_BUFFER_WARNINGS && !isRecoveringBuffer) {
       console.log("Multiple wait states detected, attempting buffer recovery");
       attemptBufferRecovery();
     }
   }
 });
 
 // Add specific event listener for progress to monitor buffer state
 video.addEventListener('progress', () => {
   if (!isMobile) return;
   
   try {
     const buffered = video.buffered;
     if (buffered.length > 0) {
       const bufferedEnd = buffered.end(buffered.length - 1);
       const duration = video.duration || 1;
       const bufferedAmount = (bufferedEnd / duration) * 100;
       
       // Log buffer percentage for debugging
       console.log(`Buffer progress: ${bufferedAmount.toFixed(1)}% of video buffered`);
       
       // If we've buffered a significant amount, reset warnings
       if (bufferedAmount > 30 && bufferWarnings > 0) {
         console.log("Buffer progress good, resetting warnings");
         bufferWarnings = 0;
       }
     }
   } catch (e) {
     console.log("Error checking buffer progress:", e);
   }
 });
 
 // Add an explicit video error recovery mechanism
 video.addEventListener('error', (e) => {
   console.error('Video error:', video.error, e);
   
   // Only show alert in development mode
   if (devToggleAllowed) {
     alert('Video error: ' + (video.error ? video.error.message : 'unknown'));
   }
   
   // Force hide spinner after video error
   hideSpinner();
   
   // For mobile, try a more aggressive reload approach
   if (isMobile) {
     setTimeout(() => {
       // Reset video source and try again
       video.pause();
       const vs = document.getElementById('videoSource');
       if (vs) {
         const currentSrc = vs.src;
         vs.src = "";
         setTimeout(() => {
           vs.src = currentSrc;
           video.load();
           // Don't auto-play after error, let user initiate
         }, 500);
       }
     }, 1000);
   }
 });
 
 // Force hide spinner after a maximum time (failsafe)
 setTimeout(() => {
   if (spinnerActive) {
     console.log("Force hiding spinner after maximum allowed time");
     spinner.style.display = 'none';
     spinnerActive = false;
   }
 }, 10000);
 
 audio.addEventListener('error', (e) => {
   console.error('Audio error:', audio.error, e);
   
   // Force hide spinner after audio error
   hideSpinner();
 });
 
 audio.addEventListener('canplay',()=>{
   audioReady=true;
   updateXrButton();
 });
 
 // Replace the existing event listeners with our debounced versions
 video.addEventListener('waiting', showSpinner);
 video.addEventListener('seeking', showSpinner);
 video.addEventListener('playing', hideSpinner);
 video.addEventListener('canplay', hideSpinner);
 audio.addEventListener('seeking', showSpinner);
 audio.addEventListener('canplay', hideSpinner);
 
 const recenter=()=>{
   camera.setAttribute('rotation','0 0 0');
   const lc=camera.components['look-controls'];
   if(lc?.pitchObject){
     lc.pitchObject.rotation.x=0;
     lc.yawObject.rotation.y=0;
   }
 };
 
 audio.addEventListener('timeupdate',()=>{
   // On mobile, sync less frequently to prevent performance issues
   if (isMobile) {
     // Only sync every few seconds and only if difference is significant
     if (xrMode && videoReady && 
         (audio.currentTime % 4 < 0.1) && // Only check roughly every 4 seconds
         Math.abs(video.currentTime - audio.currentTime) > 0.5) {
       video.currentTime = audio.currentTime;
     }
   } else {
     // Desktop can handle more frequent syncing
     if(xrMode && videoReady && Math.abs(video.currentTime-audio.currentTime) > 0.1) {
       video.currentTime = audio.currentTime;
     }
   }
   
   if(teaser&&!overlayShown&&audio.currentTime>=outroCTA_time){
     overlay.style.display='flex';
     overlayShown=true;
   }
 });
 
 // Add seeking event to keep video in sync when user scrubs audio
 audio.addEventListener('seeking', () => {
   if (xrMode && videoReady) {
     // Show spinner
     showSpinner();
     
     // For mobile, don't sync immediately as it can cause stuttering
     if (!isMobile) {
       video.currentTime = audio.currentTime;
     } else {
       // For mobile, set a timeout before syncing to reduce impact
       setTimeout(() => {
         if (xrMode && videoReady) {
           video.currentTime = audio.currentTime;
         }
       }, 200);
     }
   }
 });
 
 audio.addEventListener('seeked', () => {
   if (xrMode && videoReady) {
     // Ensure video and audio are synchronized after seeking finishes
     video.currentTime = audio.currentTime;
     
     // On mobile, give a moment before hiding spinner
     if (isMobile) {
       setTimeout(hideSpinner, 300);
     }
     
     // Ensure appropriate playback state
     if (!audio.paused && video.paused) {
       // For mobile, add a small delay before playing to ensure texture loads
       if (isMobile) {
         setTimeout(() => {
           video.play().catch(e => {
             console.error("Video play after seek error:", e);
             video.muted = true;
             video.play().catch(e => console.error("Muted play after seek failed:", e));
           });
         }, 200);
       } else {
         video.play().catch(e => {
           console.error("Video play after seek error:", e);
           video.muted = true;
           video.play().catch(e => console.error("Muted play after seek failed:", e));
         });
       }
     }
   }
 });
 
 // Create a throttled sync function to prevent too frequent synchronization
 const syncVideoToAudio = (() => {
   let lastSyncTime = 0;
   return () => {
     const now = Date.now();
     // Reduce sync frequency on mobile to prevent performance issues
     // Only sync if more than 700ms have passed since last sync on mobile (was 300ms)
     const syncInterval = isMobile ? 700 : 300;
     if (now - lastSyncTime > syncInterval && xrMode && videoReady && !video.paused && !audio.paused) {
       // Increase the threshold for sync to prevent constant adjustments
       const syncThreshold = isMobile ? 0.5 : 0.2;
       if (Math.abs(video.currentTime - audio.currentTime) > syncThreshold) {
         video.currentTime = audio.currentTime;
         lastSyncTime = now;
       }
     }
   };
 })();
 
 // Add a periodic sync check to catch drift - less frequent on mobile
 const syncInterval = setInterval(syncVideoToAudio, isMobile ? 4000 : 2000);
 
 // Cleanup interval on page unload
 window.addEventListener('beforeunload', () => {
   clearInterval(syncInterval);
 });
 
 audio.addEventListener('play',()=>{
   if(xrMode&&videoReady) {
     // First ensure times are synced before playing
     video.currentTime = audio.currentTime;
     
     // Always ensure video is muted - video should never have sound
     video.muted = true;
     
     video.play().catch((e)=>{
       console.error("Video play error:", e);
       // Retry play attempt if failed
       setTimeout(() => {
         if(isMobile) {
           video.play().catch(e => console.error("Final play attempt failed:", e));
         }
       }, 1000);
     });
   }
 });
 
 audio.addEventListener('pause',()=>{
   if(!video.paused)video.pause();
 });
 
 // Ensure video visibility
 document.addEventListener('visibilitychange', () => {
   if(!document.hidden) {
     // Only attempt to recover video if needed
     if(xrMode && videoReady && !audio.paused && video.paused) {
       // Ensure time is synced before playing
       video.currentTime = audio.currentTime;
       
       // Always keep video muted
       video.muted = true;
       video.play().catch(e => {
         console.error("Visibility play error:", e);
         setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
       });
     }
     
     // For mobile, ensure videosphere is visible
     if(isMobile && videosphere) {
       setTimeout(() => {
         videosphere.setAttribute('visible', 'true');
       }, 300);
     }
   }
 });
 
 // Add a touchstart event listener to help with iOS playback
 document.addEventListener('touchstart', () => {
   if(xrMode && videoReady && !video.playing) {
     video.play().catch(e => console.log("Touch play attempt:", e));
   }
 }, {once: true});
 
 // Add ripple effect for mobile 
 const addRippleEffect = (button) => {
   button.addEventListener('click', function(e) {
     const rect = this.getBoundingClientRect();
     const x = e.clientX - rect.left;
     const y = e.clientY - rect.top;
     
     const ripple = document.createElement('span');
     ripple.style.position = 'absolute';
     ripple.style.width = '0';
     ripple.style.height = '0';
     ripple.style.borderRadius = '50%';
     ripple.style.transform = 'translate(-50%, -50%)';
     ripple.style.pointerEvents = 'none';
     ripple.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
     ripple.style.left = `${x}px`;
     ripple.style.top = `${y}px`;
     
     this.appendChild(ripple);
     
     // Animate ripple
     ripple.animate([
       { width: '0', height: '0', opacity: 0.5 },
       { width: '200px', height: '200px', opacity: 0 }
     ], {
       duration: 600,
       easing: 'ease-out'
     }).onfinish = () => {
       ripple.remove();
     };
   });
 };
 
 // Apply ripple effect to all buttons if on mobile
 if(isMobile) {
   const buttons = document.querySelectorAll('button');
   buttons.forEach(addRippleEffect);
 }
 
 modeBtn.addEventListener('click',()=>{
   if(modeBtn.disabled)return;
   
   // Store the current play state and time to restore after mode change
   const wasPlaying = !audio.paused;
   const currentTime = audio.currentTime;
   
   // If playing, pause temporarily to prevent race conditions
   if (wasPlaying) {
     audio.pause();
     if (!video.paused) video.pause();
   }
   
   recenter();
   xrMode=!xrMode;
   layout();
   
   // Short timeout to let the DOM update before adjusting playback
   setTimeout(() => {
     // Always resync time after mode change
     if (xrMode && videoReady) {
       video.currentTime = currentTime;
     }
     
     // Resume playback if it was playing before
     if (wasPlaying) {
       audio.currentTime = currentTime; // Ensure audio time is still correct
       audio.play().then(() => {
         if (xrMode && videoReady) {
           // Always ensure video is muted
           video.currentTime = audio.currentTime; // Resync one last time
           video.muted = true;
           
           video.play().catch((e) => {
             console.error("Mode toggle play error:", e);
             setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
           });
         }
       }).catch(e => console.error("Audio resume error:", e));
     }
   }, 50);
 });
 
 recBtn.addEventListener('click',recenter);
 overlay.addEventListener('click',()=>overlay.style.display='none');
 ctaBox.addEventListener('click',e=>{e.stopPropagation();window.location.href=outroCTA_backlink});
 
 if(!devToggleAllowed)devBtn.style.display='none';
 
 devBtn.addEventListener('click',()=>{
   teaser=!teaser;
   overlay.style.display='none';
   overlayShown=false;
   xrAllowed=isXR||teaser;
   xrMode=teaser;
   layout();
 });
 
 // Handle chapter navigation
 $('prevChapter').addEventListener('click', () => {
   // You could implement chapter navigation logic here
   console.log("Previous chapter");
 });
 
 $('nextChapter').addEventListener('click', () => {
   // You could implement chapter navigation logic here
   console.log("Next chapter");
 });
 
 begin.addEventListener('click',async()=>{
   if(isMobile&&typeof DeviceOrientationEvent!=='undefined'&&DeviceOrientationEvent.requestPermission){
     try{
       await DeviceOrientationEvent.requestPermission();
     }catch(e){
       console.error("Permission error:", e);
     }
   }
   
   landing.style.display='none';
   
   // Configure video quality based on device capabilities
   configureVideoForDevice();
   
   // For mobile, try to play muted video first to help with autoplay restrictions
   if(isMobile && xrMode && videoReady) {
     video.muted = true;
     video.play().catch(e => console.log("Initial click video play:", e));
   }
   
   // Start audio
   audio.load();
   audio.play().then(()=>{
     // If we want to start paused, uncomment: audio.pause()
   }).catch((e)=>{
     console.error("Audio play error:", e);
     // Show some UI to inform user they need to interact
   });
   
   // Force A-Frame to update its rendering
   if(window.AFRAME) {
     setTimeout(() => {
       // Trigger a resize event to force A-Frame to re-render
       window.dispatchEvent(new Event('resize'));
       
       // Additional explicit rendering calls with increasing delays
       const renderAttempts = isMobile ? [100, 500] : [100, 300, 800, 1500];
       renderAttempts.forEach(delay => {
         setTimeout(() => {
           if(AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
             console.log(`Forcing render at ${delay}ms`);
             AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
             
             // Ensure videosphere is visible during each render attempt
             if(videosphere) {
               videosphere.setAttribute('visible', 'true');
             }
           }
         }, delay);
       });
     }, 100);
   }
 });
 
 xrModeBtn.addEventListener('click', () => {
   if(teaser) return;
   
   // Store the current play state and time to restore after mode change
   const wasPlaying = !audio.paused;
   const currentTime = audio.currentTime;
   
   // If playing, pause temporarily to prevent race conditions
   if (wasPlaying) {
     audio.pause();
     if (!video.paused) video.pause();
   }
   
   recenter();
   xrMode = false;
   layout();
   
   // Short timeout to let the DOM update before adjusting playback
   setTimeout(() => {
     // Resume playback if it was playing before
     if (wasPlaying) {
       audio.currentTime = currentTime; // Ensure audio time is still correct
       audio.play().catch(e => console.error("Audio resume error:", e));
     }
   }, 50);
 });
});

// Add this after the DOM content loaded event listener but before the closing script tag
document.addEventListener('aframeinitialized', function() {
  console.log("A-Frame initialized");
  
  const videosphere = document.getElementById('videosphere');
  if(videosphere) {
    videosphere.setAttribute('visible', 'true');
    console.log("Set videosphere visible on A-Frame init");
    
    // Add explicit texture optimization for the videosphere
    if (isMobile) {
      // Set texture filtering to improve performance
      try {
        const material = videosphere.getObject3D('mesh').material;
        if (material && material.map) {
          // Use a more aggressive optimization approach
          material.map.minFilter = THREE.LinearFilter;
          material.map.magFilter = THREE.LinearFilter; // Also optimize magnification filter
          material.map.generateMipmaps = false;
          material.map.format = THREE.RGBFormat; // Use RGB instead of RGBA if alpha isn't needed
          material.map.needsUpdate = true;
          
          // Optional: force texture to power-of-two dimensions for better performance
          // material.map.image.width = nearestPowerOfTwo(material.map.image.width);
          // material.map.image.height = nearestPowerOfTwo(material.map.image.height);
          
          material.needsUpdate = true;
          console.log("Applied texture optimizations to videosphere");
        }
      } catch (e) {
        console.log("Could not apply texture optimizations:", e);
      }
    }
  }

  // Add a direct optimization for the video texture update mechanism
  if (isMobile && window.THREE) {
    try {
      // Try to optimize how video textures update
      THREE.VideoTexture.prototype.update = function() {
        const video = this.image;
        if (video.readyState >= video.HAVE_CURRENT_DATA) {
          // Check if video is actually playing before updating texture
          if (!video.paused && video.currentTime > 0) {
            this.needsUpdate = true;
          }
        }
      };
      console.log("Optimized video texture update mechanism");
    } catch (e) {
      console.log("Could not optimize video texture updates:", e);
    }
  }

  // Add dynamic THREE.js settings for better performance
  if (window.THREE) {
    // Disable preserveDrawingBuffer for better performance
    THREE.WebGLRenderer.prototype.preserveDrawingBuffer = false;
  }
  
  // Configure for mobile performance
  if (isMobile && window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
    console.log("Optimizing A-Frame for mobile");
    
    // Reduce render quality for mobile
    const renderer = AFRAME.scenes[0].renderer;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio * PERFORMANCE.pixelRatioScale, 1.5));
    
    // Optimize renderer settings
    renderer.shadowMap.enabled = false;
    renderer.shadowMap.autoUpdate = false;
    renderer.physicallyCorrectLights = false;
    
    // Optional: Could disable antialiasing for better performance
    // renderer.antialias = false;
    
    // Apply further optimizations 
    if (window.THREE && THREE.ShaderChunk) {
      // Get the current scene to optimize
      const scene = AFRAME.scenes[0].object3D;
      
      // Traverse the scene to optimize geometries and materials
      scene.traverse(function(node) {
        if (node.isMesh) {
          // Disable frustum culling for videosphere (it's always visible)
          if (node.parent && node.parent.type === 'VideosphereComponent') {
            node.frustumCulled = false;
          } else {
            node.frustumCulled = true;
          }
          
          // Disable shadows
          node.castShadow = false;
          node.receiveShadow = false;
          
          // Simplify materials
          if (node.material) {
            node.material.fog = false;
            node.material.lights = false;
          }
        }
      });
    }
  }
  
  // Force another render after A-Frame is fully initialized
  setTimeout(() => {
    if(window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
      console.log("Post-initialization render");
      AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
      // Trigger resize again
      window.dispatchEvent(new Event('resize'));
    }
  }, 500);
  
  // One final attempt to hide spinner
  setTimeout(() => {
    if (spinnerActive) {
      console.log("Final attempt to hide spinner after A-Frame init");
      spinner.style.display = 'none';
      spinnerActive = false;
    }
  }, 3000);
});

// Add more robust visibility change handling
document.addEventListener('visibilitychange', () => {
  if(!document.hidden) {
    // Only attempt to recover video if needed
    if(xrMode && videoReady && !audio.paused && video.paused) {
      // Ensure time is synced before playing
      video.currentTime = audio.currentTime;
      
      // Always keep video muted
      video.muted = true;
      video.play().catch(e => {
        console.error("Visibility play error:", e);
        setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
      });
    }
    
    // For mobile, ensure videosphere is visible
    if(isMobile && videosphere) {
      setTimeout(() => {
        videosphere.setAttribute('visible', 'true');
      }, 300);
    }
  }
});

// Add some memory management
window.addEventListener('visibilitychange', () => {
  // When app goes to background on mobile, reduce memory usage
  if (document.hidden && isMobile) {
    if (window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
      // Pause video playback to conserve resources
      if (video && !video.paused) {
        video._wasPlaying = true;
        video.pause();
      }
      
      // Force a GPU resource cleanup when app is in background
      const renderer = AFRAME.scenes[0].renderer;
      
      // Release some GPU resources temporarily
      try {
        renderer.forceContextLoss();
        console.log("Forced context loss to free GPU resources while in background");
      } catch (e) {
        console.log("Could not force context loss:", e);
      }
    }
  } else if (!document.hidden) {
    // Returning to foreground
    setTimeout(() => {
      if (window.AFRAME && AFRAME.scenes[0]) {
        const scene = AFRAME.scenes[0];
        
        // Resume video if it was playing
        if (video && video._wasPlaying) {
          video._wasPlaying = false;
          video.play().catch(e => console.log("Could not resume video:", e));
        }
        
        if (scene.renderer && scene.renderer.forceContextRestore) {
          try {
            scene.renderer.forceContextRestore();
            configureVideoForDevice(); // Re-apply optimization
            console.log("Restored context after returning from background");
          } catch (e) {
            console.log("Could not restore context:", e);
          }
        }
        
        // Re-render scene
        scene.renderer.render(scene.object3D, scene.camera);
      }
    }, 300);
  }
});
</script>
</body>
</html>
