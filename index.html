<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>360° Audio‑Driven XR Player</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,sans-serif;color:#fff}

/* Container styles */
#xrContainer{position:absolute;inset:0}
#landingOverlay{position:fixed;inset:0;z-index:700;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:40px;text-align:center;gap:20px}
#audioOnly{position:absolute;top:0;left:0;right:0;display:none;flex-direction:column;align-items:center;padding-top:20px;gap:20px}

/* Artwork styles */
.artwork-wrapper{position:relative;width:calc(100% - 40px);max-width:400px}
.artwork{width:100%;aspect-ratio:1/1;border-radius:16px;object-fit:cover;box-shadow:0 4px 12px rgba(0,0,0,.4)}

/* Standard button styles */
.btn {
  border: none;
  border-radius: 8px;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #fff;
  background: rgba(60, 60, 60, 0.8);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.btn:hover {
  background: rgba(80, 80, 80, 0.9);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Button variants */
.btn-primary {
  background: rgba(78, 130, 230, 0.9);
}

.btn-primary:hover {
  background: rgba(100, 150, 255, 0.95);
}

.btn-accent {
  background: rgba(235, 87, 87, 0.9);
}

.btn-accent:hover {
  background: rgba(255, 100, 100, 0.95);
}

/* Touch device adaptations */
@media (hover: none) {
  .btn:hover {
    background: rgba(60, 60, 60, 0.8);
    transform: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }
  
  .btn-primary:hover {
    background: rgba(78, 130, 230, 0.9);
  }
  
  .btn-accent:hover {
    background: rgba(235, 87, 87, 0.9);
  }
  
  .btn:active {
    opacity: 0.7;
  }
}

/* Specific button styles */
#beginBtn{
  background: rgba(78, 130, 230, 0.9);
  border-radius: 30px;
  padding: 18px 36px;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  width: calc(100% - 40px);
  max-width: 320px;
  color: white;
}

#beginBtn:hover {
  background: rgba(100, 150, 255, 0.95);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

#toggleModeButton{
  position: absolute;
  bottom: 10px;
  right: 10px;
  border-radius: 20px;
  padding: 8px 14px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

#toggleModeButton.disabled{
  pointer-events: none;
  opacity: .5;
}

/* Status indicator */
.status-dot{
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: orange;
  display: inline-block;
}

/* Track info display */
#trackInfo{
  position: fixed;
  bottom: 140px;
  left: 50%;
  transform: translateX(-50%);
  max-width: calc(100% - 40px);
  text-align: center;
  font-size: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  z-index: 180;
}

/* Audio player */
#audioPlayer{
  position: fixed;
  bottom: 80px;
  left: 0;
  right: 0;
  margin: 0 auto;
  width: calc(100% - 20px);
  max-width: 600px;
  z-index: 200;
  background: #111;
  border-radius: 6px;
  padding: 2px 0;
}

/* Chapter navigation */
.chapter-nav{
  position: fixed;
  bottom: 10px;
  left: 0;
  right: 0;
  margin: 0 auto;
  width: calc(100% - 20px);
  max-width: 600px;
  display: flex;
  gap: 10px;
  z-index: 190;
}

.nav-btn{
  flex: 1;
  background: rgba(40, 40, 40, 0.7);
  border: none;
  border-radius: 8px;
  padding: 12px 0;
  font-size: 20px;
  color: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background: rgba(60, 60, 60, 0.9);
}

/* Top bar controls */
.top-bar{
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 150;
}

.ui-btn{
  background: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.ui-btn:hover {
  background: rgba(30, 30, 30, 0.8);
}

/* CTA overlay */
#ctaOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 500;
  cursor: pointer;
}

.cta-box{
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  transition: transform 0.2s ease;
}

.cta-box:hover {
  transform: scale(1.02);
}

.cta-logo{
  width: 120px;
  height: 120px;
  background: #fff;
  border-radius: 50%;
}

/* Loading spinner */
#loadingSpinner{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 450;
  pointer-events: none;
}

.spinner{
  width: 60px;
  height: 60px;
  border: 6px solid #fff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin{
  to{
    transform: rotate(360deg);
  }
}
</style>
</head>
<body>
<div id="landingOverlay"><h1>Welcome to the Chinatown Audio Tour</h1><p>Immerse yourself in history as you explore.</p><button id="beginBtn" class="btn">Begin Tour</button></div>
<div id="xrContainer">
  <a-scene embedded 
    vr-mode-ui="enabled:false" 
    device-orientation-permission-ui="enabled:false" 
    loading-screen="enabled:false"
    renderer="antialias: true; alpha: true; precision: high"
    onload="this.renderer.setPixelRatio(window.devicePixelRatio);">
    <a-assets>
      <video id="video360" crossorigin="anonymous" playsinline webkit-playsinline muted preload="auto">
        <source id="videoSource" type="video/mp4">
      </video>
    </a-assets>
    <a-videosphere id="videosphere" src="#video360" rotation="0 -90 0" visible="true"></a-videosphere>
    <a-entity id="cameraEntity" camera look-controls="reverseMouseDrag:true;touchEnabled:true" position="0 1.6 0"></a-entity>
  </a-scene>
</div>
<div id="audioOnly"><div class="artwork-wrapper"><img id="artworkImg" class="artwork" alt=""><button id="toggleModeButton" class="btn disabled"><span class="status-dot"></span><span>XR Mode</span></button></div></div>
<div id="trackInfo"></div>
<div class="top-bar">
  <button id="recenterButton" class="ui-btn btn">Recenter</button>
  <button id="devToggleButton" class="ui-btn btn">Toggle Teaser</button>
  <button id="xrToggleModeButton" class="ui-btn btn">Audio Only</button>
</div>
<div id="loadingSpinner"><div class="spinner"></div></div>
<audio id="audioPlayer" controls crossorigin="anonymous"></audio>
<div class="chapter-nav" id="chapterNav">
  <button id="prevChapter" class="nav-btn">&laquo;</button>
  <button id="nextChapter" class="nav-btn">&raquo;</button>
</div>
<div id="ctaOverlay"><div class="cta-box" id="ctaBox"><div class="cta-logo"></div><div class="cta-text">Take the full tour here</div></div></div>
<script>
const XR_src="https://cmm-cloud-2.s3.us-west-1.amazonaws.com/WALKING+TOURS/2025-04-10-JAPANTOWN-XR/2025-04-21-CHINATOWN-XR-UPDATE/2025-04-21-CHINATOWN-XR-2b-low.mp4";
const audio_src="https://cmm-cloud-2.s3.us-west-1.amazonaws.com/WALKING+TOURS/2025-03-15-CHINATOWN/2025-03-15-CHINATOWN-MP3S/2025-04-21-SHORTER-MP3-CHAPTERS/2025-04-21-Chapter+2+Look+Tin+Eli.mp3";
const thumbnail_src="https://placehold.co/1024x1024/1E1E1E/FFFFFF?text=Album+Art";
const chapterName="Look Tin Eli",chapterOrder=2,tourName="Chinatown Tour";
const isXR=true,isTeaser=false,outroCTA_time=20,outroCTA_backlink="https://example.com/full-tour";
const devToggleAllowed=true,isMobile=matchMedia('(pointer:coarse)').matches;
window.addEventListener('DOMContentLoaded',()=>{
 const $=id=>document.getElementById(id);
 const audio=$('audioPlayer'),video=$('video360'),vs=$('videoSource');
 const art=$('artworkImg'),track=$('trackInfo'),camera=$('cameraEntity');
 const recBtn=$('recenterButton'),modeBtn=$('toggleModeButton'),devBtn=$('devToggleButton');
 const xrModeBtn=$('xrToggleModeButton');
 const xrWrap=$('xrContainer'),audioOnly=$('audioOnly');
 const landing=$('landingOverlay'),begin=$('beginBtn');
 const spinner=$('loadingSpinner'),overlay=$('ctaOverlay'),ctaBox=$('ctaBox');
 const chapterNav=$('chapterNav');
 const videosphere=$('videosphere');
 
 // Spinner control variables
 let spinnerTimeout = null;
 let spinnerActive = false;
 
 // Control spinner with debounce
 const showSpinner = () => {
   if (spinnerTimeout) {
     clearTimeout(spinnerTimeout);
   }
   if (!spinnerActive) {
     spinner.style.display = 'flex';
     spinnerActive = true;
   }
 };
 
 const hideSpinner = () => {
   if (spinnerTimeout) {
     clearTimeout(spinnerTimeout);
   }
   // Add delay before hiding to prevent flashes
   spinnerTimeout = setTimeout(() => {
     spinner.style.display = 'none';
     spinnerActive = false;
   }, 300);
 };
 
 // Set video source
 vs.src=XR_src;
 video.load();
 
 // Always ensure video is muted regardless of other settings
 video.muted = true;
 
 // Ensure videosphere is visible
 videosphere.setAttribute('visible', 'true');
 
 // Add error logging for debugging
 video.addEventListener('error', (e) => {
   console.error('Video error:', video.error, e);
   alert('Video error: ' + (video.error ? video.error.message : 'unknown'));
 });
 
 audio.innerHTML=`<source src="${audio_src}" type="audio/mpeg">`;
 // Apply custom controls to audio element
 audio.controlsList = "nodownload nofullscreen noremoteplayback";
 // Disable playback rate controls via CSS
 const styleEl = document.createElement('style');
 styleEl.textContent = `
   #audioPlayer::-webkit-media-controls-timeline-container { display: flex !important; }
   #audioPlayer::-webkit-media-controls-play-button { display: flex !important; }
   #audioPlayer::-webkit-media-controls-current-time-display { display: flex !important; }
   #audioPlayer::-webkit-media-controls-time-remaining-display { display: flex !important; }
   #audioPlayer::-webkit-media-controls-mute-button { display: flex !important; }
   #audioPlayer::-webkit-media-controls-volume-slider { display: flex !important; }
   #audioPlayer::-webkit-media-controls-toggle-closed-captions-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-fullscreen-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-download-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-overflow-button { display: none !important; }
   #audioPlayer::-webkit-media-controls-playback-rate-button { display: none !important; }
 `;
 document.head.appendChild(styleEl);
 art.src=thumbnail_src;
 track.textContent=`Chapter ${chapterOrder} – ${chapterName} | ${tourName}`;
 let teaser=isTeaser,xrAllowed=isXR||teaser,xrMode=false;
 let videoReady=false,audioReady=false,overlayShown=false;
 const dot=modeBtn.querySelector('.status-dot');
 
 const updateXrButton=()=>{
   const ready=videoReady&&audioReady;
   modeBtn.classList.toggle('disabled',!ready);
   modeBtn.disabled=!ready;
   dot.style.background=ready?'limegreen':'orange';
 };
 
 const layout=()=>{
   modeBtn.style.display=xrAllowed&&!teaser?'inline-flex':'none';
   recBtn.style.display=xrMode?'inline-block':'none';
   xrModeBtn.style.display=(xrMode&&xrAllowed&&!teaser)?'inline-block':'none';
   chapterNav.style.display=teaser?'none':'flex';
   xrWrap.style.display=(xrMode&&xrAllowed)?'block':'none';
   audioOnly.style.display=(!xrMode||!xrAllowed)?'flex':'none';
   modeBtn.lastChild.textContent=xrMode?' Audio Only':' XR Mode';
   
   // Ensure A-Frame scene refreshes when made visible
   if(xrMode && xrAllowed) {
     forceAFrameRender();
     
     // For mobile, try to play video even if muted
     if(isMobile && videoReady && !video.playing) {
       video.play().catch(e => console.log("Initial mobile play attempt:", e));
     }
   }
 };
 
 // Modify force render function to manage spinner state 
 const forceAFrameRender = () => {
   // Show spinner at the beginning of render attempts
   showSpinner();
   
   if(window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
     console.log("Forcing A-Frame render");
     AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
     window.dispatchEvent(new Event('resize'));
     
     // Explicitly check videosphere visibility
     if(videosphere) {
       videosphere.setAttribute('visible', 'true');
       console.log("Ensuring videosphere visibility");
     }
     
     // Schedule multiple renders with increasing delays
     const renderDelays = [100, 400, 800, 1500]; 
     let lastDelay = Math.max(...renderDelays);
     
     renderDelays.forEach(delay => {
       setTimeout(() => {
         if(AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
           console.log(`Scheduled render at ${delay}ms`);
           AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
           
           // Check videosphere visibility again during each render
           if(videosphere) {
             videosphere.setAttribute('visible', 'true');
           }
           
           // Only hide spinner after the last render attempt
           if (delay === lastDelay) {
             hideSpinner();
           }
         }
       }, delay);
     });
   } else {
     // If A-Frame isn't ready, hide spinner after timeout
     setTimeout(hideSpinner, 800);
   }
 };
 
 // Setup observer to detect when container becomes visible
 const containerObserver = new MutationObserver((mutations) => {
   mutations.forEach((mutation) => {
     if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
       const target = mutation.target;
       if (target.style.display === 'block' && target.id === 'xrContainer') {
         console.log("XR container now visible - forcing render");
         forceAFrameRender();
       }
     }
   });
 });
 
 // Start observing the container for visibility changes
 containerObserver.observe(xrWrap, { attributes: true });
 
 if(teaser)xrMode=true;
 layout();
 updateXrButton();
 
 // Video loading events
 video.addEventListener('loadedmetadata', () => {
   console.log("Video metadata loaded");
 });
 
 video.addEventListener('loadeddata',()=>{
   console.log("Video data loaded");
   videoReady=true;
   updateXrButton();
   
   // Force renderer update
   if(window.AFRAME && AFRAME.scenes[0]) {
     AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
     
     // Ensure videosphere is visible after video loads
     if(videosphere) {
       videosphere.setAttribute('visible', 'true');
     }
   }
   
   hideSpinner();
   
   // For mobile, try to play muted video once it's loaded
   if(isMobile && xrMode) {
     video.muted = true;
     video.play().catch(e => console.log("Auto-play attempt after load:", e));
   }
 });
 
 audio.addEventListener('canplay',()=>{
   audioReady=true;
   updateXrButton();
 });
 
 // Replace the existing event listeners with our debounced versions
 video.addEventListener('waiting', showSpinner);
 video.addEventListener('seeking', showSpinner);
 video.addEventListener('playing', hideSpinner);
 video.addEventListener('canplay', hideSpinner);
 audio.addEventListener('seeking', showSpinner);
 audio.addEventListener('canplay', hideSpinner);
 
 const recenter=()=>{
   camera.setAttribute('rotation','0 0 0');
   const lc=camera.components['look-controls'];
   if(lc?.pitchObject){
     lc.pitchObject.rotation.x=0;
     lc.yawObject.rotation.y=0;
   }
 };
 
 audio.addEventListener('timeupdate',()=>{
   if(xrMode && videoReady && Math.abs(video.currentTime-audio.currentTime)>0.1) {
     video.currentTime=audio.currentTime;
   }
   
   if(teaser&&!overlayShown&&audio.currentTime>=outroCTA_time){
     overlay.style.display='flex';
     overlayShown=true;
   }
 });
 
 // Add seeking event to keep video in sync when user scrubs audio
 audio.addEventListener('seeking', () => {
   if (xrMode && videoReady) {
     video.currentTime = audio.currentTime;
   }
 });
 
 audio.addEventListener('seeked', () => {
   if (xrMode && videoReady) {
     // Ensure video and audio are synchronized after seeking finishes
     video.currentTime = audio.currentTime;
     
     // Ensure appropriate playback state
     if (!audio.paused && video.paused) {
       video.play().catch(e => {
         console.error("Video play after seek error:", e);
         // Try with muted as fallback
         video.muted = true;
         video.play().catch(e => console.error("Muted play after seek failed:", e));
       });
     }
   }
 });
 
 // Create a throttled sync function to prevent too frequent synchronization
 const syncVideoToAudio = (() => {
   let lastSyncTime = 0;
   return () => {
     const now = Date.now();
     // Only sync if more than 300ms have passed since last sync
     if (now - lastSyncTime > 300 && xrMode && videoReady && !video.paused && !audio.paused) {
       if (Math.abs(video.currentTime - audio.currentTime) > 0.2) {
         video.currentTime = audio.currentTime;
         lastSyncTime = now;
       }
     }
   };
 })();
 
 // Add a periodic sync check to catch drift
 const syncInterval = setInterval(syncVideoToAudio, 2000);
 
 // Cleanup interval on page unload
 window.addEventListener('beforeunload', () => {
   clearInterval(syncInterval);
 });
 
 audio.addEventListener('play',()=>{
   if(xrMode&&videoReady) {
     // First ensure times are synced before playing
     video.currentTime = audio.currentTime;
     
     // Always ensure video is muted - video should never have sound
     video.muted = true;
     
     video.play().catch((e)=>{
       console.error("Video play error:", e);
       // Retry play attempt if failed
       setTimeout(() => {
         if(isMobile) {
           video.play().catch(e => console.error("Final play attempt failed:", e));
         }
       }, 1000);
     });
   }
 });
 
 audio.addEventListener('pause',()=>{
   if(!video.paused)video.pause();
 });
 
 // Ensure video visibility
 document.addEventListener('visibilitychange', () => {
   if(!document.hidden) {
     // Only attempt to recover video if needed
     if(xrMode && videoReady && !audio.paused && video.paused) {
       // Ensure time is synced before playing
       video.currentTime = audio.currentTime;
       
       // Always keep video muted
       video.muted = true;
       video.play().catch(e => {
         console.error("Visibility play error:", e);
         setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
       });
     }
     
     // For mobile, ensure videosphere is visible
     if(isMobile && videosphere) {
       setTimeout(() => {
         videosphere.setAttribute('visible', 'true');
       }, 300);
     }
   }
 });
 
 // Add a touchstart event listener to help with iOS playback
 document.addEventListener('touchstart', () => {
   if(xrMode && videoReady && !video.playing) {
     video.play().catch(e => console.log("Touch play attempt:", e));
   }
 }, {once: true});
 
 // Add ripple effect for mobile 
 const addRippleEffect = (button) => {
   button.addEventListener('click', function(e) {
     const rect = this.getBoundingClientRect();
     const x = e.clientX - rect.left;
     const y = e.clientY - rect.top;
     
     const ripple = document.createElement('span');
     ripple.style.position = 'absolute';
     ripple.style.width = '0';
     ripple.style.height = '0';
     ripple.style.borderRadius = '50%';
     ripple.style.transform = 'translate(-50%, -50%)';
     ripple.style.pointerEvents = 'none';
     ripple.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
     ripple.style.left = `${x}px`;
     ripple.style.top = `${y}px`;
     
     this.appendChild(ripple);
     
     // Animate ripple
     ripple.animate([
       { width: '0', height: '0', opacity: 0.5 },
       { width: '200px', height: '200px', opacity: 0 }
     ], {
       duration: 600,
       easing: 'ease-out'
     }).onfinish = () => {
       ripple.remove();
     };
   });
 };
 
 // Apply ripple effect to all buttons if on mobile
 if(isMobile) {
   const buttons = document.querySelectorAll('button');
   buttons.forEach(addRippleEffect);
 }
 
 modeBtn.addEventListener('click',()=>{
   if(modeBtn.disabled)return;
   
   // Store the current play state and time to restore after mode change
   const wasPlaying = !audio.paused;
   const currentTime = audio.currentTime;
   
   // If playing, pause temporarily to prevent race conditions
   if (wasPlaying) {
     audio.pause();
     if (!video.paused) video.pause();
   }
   
   recenter();
   xrMode=!xrMode;
   layout();
   
   // Short timeout to let the DOM update before adjusting playback
   setTimeout(() => {
     // Always resync time after mode change
     if (xrMode && videoReady) {
       video.currentTime = currentTime;
     }
     
     // Resume playback if it was playing before
     if (wasPlaying) {
       audio.currentTime = currentTime; // Ensure audio time is still correct
       audio.play().then(() => {
         if (xrMode && videoReady) {
           // Always ensure video is muted
           video.currentTime = audio.currentTime; // Resync one last time
           video.muted = true;
           
           video.play().catch((e) => {
             console.error("Mode toggle play error:", e);
             setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
           });
         }
       }).catch(e => console.error("Audio resume error:", e));
     }
   }, 50);
 });
 
 recBtn.addEventListener('click',recenter);
 overlay.addEventListener('click',()=>overlay.style.display='none');
 ctaBox.addEventListener('click',e=>{e.stopPropagation();window.location.href=outroCTA_backlink});
 
 if(!devToggleAllowed)devBtn.style.display='none';
 
 devBtn.addEventListener('click',()=>{
   teaser=!teaser;
   overlay.style.display='none';
   overlayShown=false;
   xrAllowed=isXR||teaser;
   xrMode=teaser;
   layout();
 });
 
 // Handle chapter navigation
 $('prevChapter').addEventListener('click', () => {
   // You could implement chapter navigation logic here
   console.log("Previous chapter");
 });
 
 $('nextChapter').addEventListener('click', () => {
   // You could implement chapter navigation logic here
   console.log("Next chapter");
 });
 
 begin.addEventListener('click',async()=>{
   if(isMobile&&typeof DeviceOrientationEvent!=='undefined'&&DeviceOrientationEvent.requestPermission){
     try{
       await DeviceOrientationEvent.requestPermission();
     }catch(e){
       console.error("Permission error:", e);
     }
   }
   
   landing.style.display='none';
   
   // For mobile, try to play muted video first to help with autoplay restrictions
   if(isMobile && xrMode && videoReady) {
     video.muted = true;
     video.play().catch(e => console.log("Initial click video play:", e));
   }
   
   // Start audio
   audio.load();
   audio.play().then(()=>{
     // If we want to start paused, uncomment: audio.pause()
   }).catch((e)=>{
     console.error("Audio play error:", e);
     // Show some UI to inform user they need to interact
   });
   
   // Force A-Frame to update its rendering
   if(window.AFRAME) {
     setTimeout(() => {
       // Trigger a resize event to force A-Frame to re-render
       window.dispatchEvent(new Event('resize'));
       
       // Additional explicit rendering calls with increasing delays
       const renderAttempts = [100, 300, 800, 1500];
       renderAttempts.forEach(delay => {
         setTimeout(() => {
           if(AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
             console.log(`Forcing render at ${delay}ms`);
             AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
             
             // Ensure videosphere is visible during each render attempt
             if(videosphere) {
               videosphere.setAttribute('visible', 'true');
             }
           }
         }, delay);
       });
     }, 100);
   }
 });
 
 xrModeBtn.addEventListener('click', () => {
   if(teaser) return;
   
   // Store the current play state and time to restore after mode change
   const wasPlaying = !audio.paused;
   const currentTime = audio.currentTime;
   
   // If playing, pause temporarily to prevent race conditions
   if (wasPlaying) {
     audio.pause();
     if (!video.paused) video.pause();
   }
   
   recenter();
   xrMode = false;
   layout();
   
   // Short timeout to let the DOM update before adjusting playback
   setTimeout(() => {
     // Resume playback if it was playing before
     if (wasPlaying) {
       audio.currentTime = currentTime; // Ensure audio time is still correct
       audio.play().catch(e => console.error("Audio resume error:", e));
     }
   }, 50);
 });
});

// Add this after the DOM content loaded event listener but before the closing script tag
document.addEventListener('aframeinitialized', function() {
  console.log("A-Frame initialized");
  
  const videosphere = document.getElementById('videosphere');
  if(videosphere) {
    videosphere.setAttribute('visible', 'true');
    console.log("Set videosphere visible on A-Frame init");
  }
  
  // Force another render after A-Frame is fully initialized
  setTimeout(() => {
    if(window.AFRAME && AFRAME.scenes[0] && AFRAME.scenes[0].renderer) {
      console.log("Post-initialization render");
      AFRAME.scenes[0].renderer.render(AFRAME.scenes[0].object3D, AFRAME.scenes[0].camera);
      // Trigger resize again
      window.dispatchEvent(new Event('resize'));
    }
  }, 500);
});

// Add video playback rate matching to ensure smoother playback
video.addEventListener('ratechange', () => {
  // If audio changes speed, match video speed
  if (xrMode && videoReady && video.playbackRate !== audio.playbackRate) {
    video.playbackRate = audio.playbackRate;
  }
});

// Add more robust visibility change handling
document.addEventListener('visibilitychange', () => {
  if(!document.hidden) {
    // Only attempt to recover video if needed
    if(xrMode && videoReady && !audio.paused && video.paused) {
      // Ensure time is synced before playing
      video.currentTime = audio.currentTime;
      
      // Always keep video muted
      video.muted = true;
      video.play().catch(e => {
        console.error("Visibility play error:", e);
        setTimeout(() => video.play().catch(e => console.error("Retry play failed:", e)), 500);
      });
    }
    
    // For mobile, ensure videosphere is visible
    if(isMobile && videosphere) {
      setTimeout(() => {
        videosphere.setAttribute('visible', 'true');
      }, 300);
    }
  }
});
</script>
</body>
</html>
